#!/usr/bin/env python

import rospy
import os

from io import BytesIO
from lxml import etree
from carla_msgs.msg import CarlaWorldInfo
from opendrive2lanelet.opendriveparser.parser import parse_opendrive
from opendrive2lanelet.network import Network
from opendrive2lanelet.osm.lanelet2osm import L2OSMConverter
from commonroad.common.file_writer import CommonRoadFileWriter, OverwriteExistingFile
from commonroad.planning.planning_problem import PlanningProblemSet
from commonroad.scenario.scenario import Tag
from commonroad.scenario.scenario import Scenario
import numpy as np
import math
from commonroad.scenario.lanelet import Lanelet

import tempfile
# !/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

import glob
import os
import sys
from pprint import pprint
from geometry_msgs.msg import Point

try:
    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

import carla


class LandMarkPoint:
    """
    Class that represents a LandMark Object and contains its absolute position, defined by x, y and its orientation,
    and its designated id.
    """

    def __init__(self, x: float, y: float, orientation: float, id: int):
        """
        LandMarkPointObject
        :param x: x position [m]
        :param y: y position [m]
        :param orientation: for this specific purpose: yaw_angle as a rotation by the z-axis [degree]
        :param id: landmark id, set by carla
        """
        self.x = x
        self.y = y
        # get orientation without multiple rotations
        self.orientation = orientation % 360
        # get the positive angle
        if self.orientation < 0:
            self.orientation = self.orientation + 360

        self.mark_id = id

    def __eq__(self, other):
        return self.mark_id == other.mark_id

    def __hash__(self):
        return hash(self.mark_id)


def get_markings():
    # In this tutorial script, we are going to add a vehicle to the simulation
    # and let it drive in autopilot. We will also create a camera attached to
    # that vehicle, and save all the images generated by the camera to disk.

    try:
        # First of all, we need to create the client that will send the requests
        # to the simulator. Here we'll assume the simulator is accepting
        # requests in the localhost at port 2000.
        client = carla.Client('localhost', 2000)
        client.set_timeout(2.0)

        # Once we have a client we can retrieve the world that is currently
        # running.
        world = client.get_world()
        markings = {}
        marks = world.get_map().get_all_landmarks()
        for mark in marks:
            if mark.name in markings:
                markings[mark.name].add(
                    LandMarkPoint(mark.transform.location.x, -mark.transform.location.y, mark.transform.rotation.yaw,
                                  int(mark.id)))
            else:
                markings[mark.name] = set()
                markings[mark.name].add(
                    LandMarkPoint(mark.transform.location.x, -mark.transform.location.y, mark.transform.rotation.yaw,
                                  int(mark.id)))
        return markings
    finally:

        print('destroying actors')
        # client.apply_batch([carla.command.DestroyActor(x) for x in actor_list])
        print('done.')


class MapProvider:

    def __init__(self, init_rospy: bool = False):
        self.osm_file = tempfile.NamedTemporaryFile(suffix=".osm")
        # opendrive map received from the _world_info_subscriber
        self.map: str = None
        # name of the map received from the _world_info_subscriber
        self.map_name: str = None
        # boolean that represents the availability of the opendrive map -> true if the map was received by the subscriber
        self.map_ready: bool = False
        # starts the logging node , normally only needed if the module is used independently
        if init_rospy:
            rospy.init_node('mapProvider', anonymous=True)

        # Subscriber to receive the currently loaded map
        self._world_info_subscriber = rospy.Subscriber(
            "/carla/world_info", CarlaWorldInfo, self.update_world)

    def __del__(self):
        # closing the TemporaryFile deletes it
        self.osm_file.close()

    def update_world(self, world_info: CarlaWorldInfo):
        """
        Check if a new map was sent and receive it
        """
        self.map_ready = False
        rospy.loginfo("MapProvider: Received new map info")
        if self.map_name == world_info.map_name:
            rospy.loginfo("MapProvider: Map already loaded")
        else:
            self.map_name = world_info.map_name
            self.map = world_info.opendrive
            self.map_ready = True
            rospy.loginfo("MapProvider: Received: " + self.map_name)

    def convert_to_osm(self) -> str:
        """
        Create a temporary OpenStreetMap file that can be used to generate a lanelet2 LaneletMap
        """
        lanelet = self.convert_od_to_lanelet()
        if lanelet is not None:
            l2osm = L2OSMConverter(
                "+proj=omerc +lat_0=0 +lonc=0 +alpha=0 +k=1 +x_0=0 +y_0=0 +gamma=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0")
            openstreetmap = etree.tostring(l2osm(lanelet), xml_declaration=True, encoding="UTF-8", pretty_print=True)
            self.osm_file.write(openstreetmap)
            rospy.loginfo("MapProvider: Temporary file created:" + os.path.abspath(self.osm_file.name))
            return os.path.abspath(self.osm_file.name)
        else:
            rospy.logerr("MapProvider: lanelet not available")
            rospy.logerr("MapProvider: Couldn't create temporary file")
            return ""

    """
    Currently not in use since CommonRoad lanlets are not compatible with lanelet2
    """

    def convert_od_to_lanelet(self) -> Scenario:
        """
        Create a CommonRoad scenario from the OpenDrive received OpenDrive map
        """
        lanelet: Scenario = None
        if self.map_ready:
            rospy.loginfo("MapProvider: Start conversion...")
            opendrive = parse_opendrive(etree.parse(BytesIO(self.map.encode('utf-8'))).getroot())
            roadNetwork = Network()
            roadNetwork.load_opendrive(opendrive)
            lanelet = roadNetwork.export_commonroad_scenario()
            landmarks = get_markings()
            self._traffic_lights_to_scenario(landmarks, lanelet)
            rospy.loginfo("MapProvider: Conversion done!")
        return lanelet

    def _find_nearest_lanlet(self, goal: Point, scenario):
        """
        Given a Point (x,y,z) -> find nearest lanelet
        :param goal: point to which the nearest lanelet should be searched
        :return: nearest lanelet to point goal
        """
        nearest = None
        curr_radius = 1
        step_size = 0.5
        max_radius = 100
        while curr_radius < max_radius or nearest is not None:
            nearest = scenario.lanelet_network.lanelets_in_proximity(np.array([goal.x, goal.y]), curr_radius)
            if len(nearest) == 0:
                nearest = None
                curr_radius += step_size
            else:
                return nearest[0]
        return None

    def _traffic_lights_to_scenario(self, landmarks, map: Scenario):
        lights = landmarks['Signal_3Light_Post01']
        for light in lights:
            lanelet: Lanelet = self._find_nearest_lanlet(light, map)

            if light.mark_id == 2021:
                print("Light orientation" + str(light.orientation))
                print("lanelet orientation" + str(self._get_lanelet_end_orientation_to_light(lanelet)))
                print("Lanelet id" + str(lanelet.lanelet_id))

            # check whether the orientation of the traffic light and the corresponding lanelet matches
            # allow a absolut tolerance of 20 degrees to consider a traffic light associated with the lanelet
            angle_diff = 180 - abs(abs(light.orientation - self._get_lanelet_end_orientation_to_light(lanelet)) - 180)
            if angle_diff < 20:
                # add traffic light to the predecessor of the lanelet
                print("[{}, {}] ID: {} -> {} (lanlet_id)".format(light.x, light.y, light.mark_id, lanelet.lanelet_id))

    """
    The generate methods are just for debugging purposes 
    """

    def generate_osm_file(self):
        lanelet = self.convert_od_to_lanelet()
        if lanelet is not None:
            l2osm = L2OSMConverter(
                "+proj=omerc +lat_0=0 +lonc=0 +alpha=0 +k=1 +x_0=0 +y_0=0 +gamma=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0")
            openstreetmap = etree.tostring(l2osm(lanelet), xml_declaration=True, encoding="UTF-8", pretty_print=True)

            # write osm file
            with open(self.map_name + ".osm", "wb") as file_out:
                file_out.write(openstreetmap)
            rospy.loginfo("MapProvider: Wrote file" + self.map_name + ".osm")
        else:
            rospy.logerr("MapProvider: lanelet not available")
            rospy.logerr("MapProvider: No file generated")

    def generate_com_road_file(self):
        lanelet = self.convert_od_to_lanelet()
        if lanelet is not None:
            writer = CommonRoadFileWriter(
                scenario=lanelet,
                planning_problem_set=PlanningProblemSet(),
                author="Psaf1",
                affiliation="",
                source="MapProvider",
                tags={Tag.URBAN, Tag.HIGHWAY},
            )
            # write CommonRoad data to xml file
            writer.write_to_file(self.map_name + ".xml", OverwriteExistingFile.ALWAYS)
            rospy.loginfo("MapProvider: Wrote file" + self.map_name + ".xml")
        else:
            rospy.logerr("MapProvider: lanelet not available")
            rospy.logerr("MapProvider: No file generated")

    def _get_lanelet_end_orientation_to_light(self, lanelet: Lanelet):
        prev_pos = lanelet.center_vertices[-2]
        pos = lanelet.center_vertices[-1]

        # describes the relativ position of the pos to the prev pos
        rel_x = 1 if (pos[0] - prev_pos[0]) >= 0 else -1
        rel_y = 1 if (prev_pos[1] - pos[1]) >= 0 else -1

        euler_angle_yaw = math.degrees(math.atan2(rel_y * abs(pos[1] - prev_pos[1]), rel_x * abs(pos[0] - prev_pos[0])))

        # get orientation without multiple rotations
        euler_angle_yaw = euler_angle_yaw % 360
        # get the positive angle
        if euler_angle_yaw < 0:
            euler_angle_yaw = euler_angle_yaw + 360

        return euler_angle_yaw


def main():
    provider = MapProvider(True)
    while not provider.map_ready:
        rospy.loginfo("Waiting")
    provider.convert_od_to_lanelet()


if __name__ == "__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass
